#!/usr/bin/env python3

import argparse
import copy
import json
import os
import shlex
import subprocess
import sys

import i3ipc


MARK_QT_PATTERN = 'quickterm_.*'
MARK_QT = 'quickterm_{}'


DEFAULT_CONF = {
    'menu': 'rofi -dmenu -p "quickterm: " -no-custom -auto-select',
    'term': 'urxvt',
    'ratio': 0.25,
    'pos': 'top',
    'shells': {
        'haskell': 'ghci',
        'js': 'node',
        'python': 'ipython3 --no-banner',
        'shell': os.environ.get('SHELL', 'bash'),
    }
}


def conf_path():
    home_dir = os.environ['HOME']
    xdg_dir = os.environ.get('XDG_CONFIG_DIR', '{}/.config'.format(home_dir))

    return xdg_dir + '/i3/i3-quickterm.json'


def read_conf(fn):
    try:
        with open(fn, 'r') as f:
            c = json.load(f)
        return c
    except Exception as e:
        return {}


def move_back(conn, selector):
    conn.command('{} floating enable, move scratchpad'
                 .format(selector))


def pop_it(conn, mark_name, pos='top', ratio=0.25):
    ws, _ = get_current_workspace(conn)
    wx, wy = ws['rect']['x'], ws['rect']['y']
    wwidth, wheight = ws['rect']['width'], ws['rect']['height']

    width = wwidth
    height = int(wheight*ratio)
    posx = wx

    if pos == 'bottom':
        margin = 6
        posy = wy + wheight - height - margin
    else:  # pos == 'top'
        posy = wy

    conn.command('[con_mark={mark}],'
                 'resize set {width} px {height} px,'
                 'move absolute position {posx}px {posy}px,'
                 'move scratchpad,'
                 'scratchpad show'
                 ''.format(mark=mark_name, posx=posx, posy=posy,
                           width=width, height=height))


def get_current_workspace(conn):
    ws = [w for w in conn.get_workspaces() if w['focused']][0]
    tree = conn.get_tree()

    # wname = workspace['name']
    ws_tree = [c for c in tree.descendents()
               if c.type == 'workspace' and c.name == ws['name']][0]

    return ws, ws_tree


def toggle_quickterm_select(conf):
    """Hide a quickterm visible on current workspace or prompt
    the user for a shell type"""
    conn = i3ipc.Connection()
    ws, ws_tree = get_current_workspace(conn)

    # is there a quickterm opened in the current workspace?
    qt = ws_tree.find_marked(MARK_QT_PATTERN)
    if qt:
        qt = qt[0]
        move_back(conn, '[con_id={}]'.format(qt.id))
        return

    proc = subprocess.Popen(shlex.split(conf['menu']), stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE)
    for r in sorted(conf['shells'].keys()):
        proc.stdin.write((r + '\n').encode())
    stdout, _ = proc.communicate()

    shell = stdout.decode().strip()

    if shell not in conf['shells']:
        return

    toggle_quickterm(conf, shell)


def toggle_quickterm(conf, shell):
    conn = i3ipc.Connection()
    tree = conn.get_tree()
    shell_mark = MARK_QT.format(shell)
    qt = tree.find_marked(shell_mark)

    # does it exist already?
    if len(qt) == 0:
        subprocess.call(shlex.split(conf['term']) + ['-e', sys.argv[0], '-i', shell])
    else:
        qt = qt[0]
        ws, ws_tree = get_current_workspace(conn)

        move_back(conn, '[con_id={}]'.format(qt.id))
        if qt.workspace().name != ws.name:
            pop_it(conn, shell_mark)


def launch_inplace(conf, shell):
    conn = i3ipc.Connection()
    shell_mark = MARK_QT.format(shell)
    conn.command('mark {}'.format(shell_mark))
    move_back(conn, '[con_mark={}]'.format(shell_mark))
    pop_it(conn, shell_mark)
    prog_cmd = shlex.split(conf['shells'][shell])
    subprocess.call(prog_cmd)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--in-place', dest='in_place',
                        action='store_true')
    parser.add_argument('shell', metavar='SHELL', nargs='?')
    args = parser.parse_args()

    conf = copy.deepcopy(DEFAULT_CONF)
    conf.update(read_conf(conf_path()))

    if args.shell is None:
        toggle_quickterm_select(conf)
        sys.exit(0)

    if args.shell not in conf['shells']:
        print('unknown shell {}'.format(args.shell), file=sys.stderr)
        sys.exit(1)

    if args.in_place:
        launch_inplace(conf, args.shell)
    else:
        toggle_quickterm(conf, args.shell)
